%% ------------------------------------------------------------------------- %%
\chapter{Trabalhos relacionados}
\label{cap:trabalhos-relacionados}



%% ------------------------------------------------------------------------- %%
\section{Recuperação de trecho de código-fonte ou \textit{Code retrieval}}
\label{sec:code-retrieval}

De acordo com \cite{iyer-etal-2016-summarizing}, o problema de recuperação de trecho de código-fonte ou \textit{code retrieval} é definido como:

Seja $U_{C}$ o conjunto de trechos de código-fonte e $U_{D}$ o conjunto de descrições em linguagem natural. 

\textbf{RET:} Seja $n$ uma descrição, $n \in U_{D}$, e $C_{A}$ um conjunto trechos de código-fonte $\{c_{1}, c_{2}, ..., c_{m}\}$, $C_{A} \subset U_{C}$. Dado uma descrição $n$, o objetivo é recuperar o trecho de código-fonte $c_{j}^{*}$ do conjunto $C_{A}$, que obtenha o maior valor a partir de uma função $s$, $s \in (U_{C} X U_{D} \rightarrow \rm I\!R)$:

\begin{equation}\label{eq:code-retrieval}
c_{j}^{*} = \underset{c_{j}}{argmax} \{s(c_{j} , n)\}, 1 \leq j \leq m   
\end{equation}


Esta definição servirá de base para o problema proposto para este trabalho. Uma das primeiras referências ao problema do \textit{code retrieval} foi o trabalho de \cite{Allamanis-bimodal-source-code-natural-language:2015}. E a definição formal do problema enunciada acima na equação~\ref{eq:code-retrieval} foi proposta posteriormente por \cite{iyer-etal-2016-summarizing}. 

Há outros trabalhos \citep{Gu-deep-code-search:2018, Sachdev-neural-code-search:2018, cambronero-deep-learning-code-search:2019} que utilizam o termo \textit{code search} para o mesmo problema definido por \cite{iyer-etal-2016-summarizing}. Neste trabalho, tanto o termo \textit{code retrieval} quanto \textit{code search} irão referir-se ao mesmo problema.

\subsection{Trabalhos relacionados}\label{sec:code-retrieval-trabalhos-relacionados}

\textit{Code search} ou \textit{code retrieval} busca associar um texto em linguagem natural a um código-fonte. Esta associação tem diversas aplicações em engenharia de software conforme exposto no capítulo~\ref{cap:introducao}.

Conforme citado na seção~\ref{sec:code-retrieval}, o trabalho de \cite{Allamanis-bimodal-source-code-natural-language:2015} foi um dos primeiros sobre o problema do \textit{code retrieval}. Neste trabalho utilizou-se vetores de \gls{representacao-distribuida} tanto para as descrições quanto para os trechos de código-fonte. Uma função de classificação foi utilizada para combinar os vetores. A combinação foi feita usando operações aditivas ou multiplicativas. Ao final, o valor obtido a partir da função de classificação é transformada em probabilidade para avaliar qual trecho de código-fonte é mais relevante para uma determinada questão.

Já \cite{iyer-etal-2016-summarizing} utilizou uma rede neural recorrente, mais especificamente \acrshort{lstm} com o \gls{mecanismo-atencao} para classificar o trecho de código-fonte de acordo com a questão.



%% ------------------------------------------------------------------------- %%
\section{Seleção de respostas ou \textit{Answer selection}}
\label{sec:answer-selection}

De acordo com \cite{shao-answer-selection:2019}, a definição formal para o problema de seleção de respostas ou \textit{answer selection} é:

\textbf{Definição:} Dado uma questão $q$ e dois conjuntos de respostas, um conjunto com respostas candidatas $A$ contendo $m$ possíveis respostas para a questão $q$, i.e., $A : \{ a_{1}, a_{2}, . . ., a_{m}\}$ e um conjunto $G$ com as respostas de fato, i.e, $G : \{ g_{1}, g_{2}, . . ., g{n}\}$, onde $n$ é a quantidade de respostas corretas coletadas para $q$. O objetivo do \textit{answer selection} é selecionar a resposta correta de $q$ do conjunto $A$. Se a resposta selecionada $a_{X}$, tal que $a_{x} \in G$, então a seleção será considerada um sucesso. Caso contrário, falho.

\subsection{Trabalhos relacionados}\label{sec:answer-selection-trabalhos-relacionados}

%% ------------------------------------------------------------------------- %%
\section{Uso de deep learning}
\label{sec:uso-deep-learning}

A maioria dos modelos citados na seção anterior tentam solucionar o problema de perguntas e respostas em linguagem natural. Porém, com o advento do Big Code, repositórios open source, outros problemas que envolvem uma complexidade maior surgem. Por exemplo, dado uma sentença em linguagem natural, uma pergunta, qual a resposta poderiamos ter em uma linguagem estrutural como Java, XML ou Python? Ou até mesmo SQL? A partir de análises de commits do github, podemos aferir a partir de uma estória de usuário, quais alterações são necessárias para concluir aquela tarefa, por exemplo. No nosso caso, a partir do database do stackoverflow, queremos saber a partir de uma pergunta, qual o código fonte é a solução.